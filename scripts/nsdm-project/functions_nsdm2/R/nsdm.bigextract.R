#' nsdm.bigextract
#'
#' Parallelized loading and spatiotemporal extraction of large raster datasets.
#'
#' @param cov A character vector specifying the file paths of individual raster layers.
#' @param data An `nsdm.pseudoabsences` object used for covariate extraction.
#' @param rst_ref A raster object used as a reference (for cell identifiers, CRS, extent, etc.).
#' @param cov_info A `data.frame` containing key covariate information, as generated by `nsdm.covinfo`.
#' @param t_match Logical; whether to perform temporal matching (`TRUE`) or not (`FALSE`).
#' @param tmatch_scheme A character string specifying the temporal matching scheme:  
#'   - `"npts"`: nearest previous time slice  
#'   - `"nts"`: nearest time slice
#' @param ex_pint Logical; whether to treat period interval covariates as static (`TRUE`) or not (`FALSE`).
#' @param nzvt A numeric threshold specifying the minimum number of unique values required for a covariate to be retained in the candidate set.
#' @param nsplits An integer indicating the number of cores to use for parallel extraction.
#'
#' @return An updated `nsdm.pseudoabsences` object.
#' @author Antoine Adde (antoine.adde@eawag.ch)
#' @export

nsdm.bigextract<-function(cov, data, rst_ref, cov_info, t_match=FALSE, tmatch_scheme="npts", ex_pint=TRUE, nzvt=10, nsplits=ncores){

 # Get data
xy <- data@xy
pa <- data@pa
years <- data@years

# Isolate fst and tif covariates
cov_tif <- cov[grep("\\.tif$", cov)]  # should only be mainGLO
cov_fst <- cov[grep("\\.fst$", cov)]

### ------------------------
### Arrange layers for temporal matching or not
### ------------------------

# Retrieve cov-info table
cov_info_fst <- data.frame(cov_info[match(gsub("\\.fst$", "", basename(cov_fst)), 
                                          gsub("\\.tif$", "", basename(cov_info$file))), ])
cov_info_fst <- cov_info_fst[!is.na(cov_info_fst$variable), ]

# Extract relevant time columns
times <- cov_info_fst[, c("start_year", "end_year", "variable", "dataset")]
times$start_year <- as.numeric(times$start_year)
times$end_year <- as.numeric(times$end_year)
times$id <- seq_len(nrow(times))

# Identify layers for which temporal information is available
tempo_t <- times[complete.cases(times), ]
stat_t <- times[!complete.cases(times), ]

# Generate period interval look-up table
ints <- unique(tempo_t[, c("start_year", "end_year", "dataset")])
p_ints_t <- data.frame()
for (dt in unique(ints$dataset)) {
  a <- ints[ints$dataset == dt, ]
  a$diff <- a$end_year - a$start_year
  a_ix <- which(a$end_year == max(a$end_year))
  if (length(a_ix) > 1) a_ix <- a_ix[which(a$diff[a_ix] == max(a$diff[a_ix]))]
  a$int <- ifelse(length(unique(a$diff)) > 1, "int", "no_int")
  p_ints_t <- rbind(p_ints_t, data.frame(dataset = dt, 
                                          start_year = a$start_year[a_ix], 
                                          end_year = a$end_year[a_ix], 
                                          int = a$int[a_ix]))
}

# If temporal matching is enabled
if (exists("t_match") && t_match) {
  if (ex_pint) {
    ints <- tempo_t[tempo_t$dataset %in% unique(p_ints_t[p_ints_t$int == "int", ]$dataset), ]
    for (dt in unique(ints$dataset)) {
      ints_i <- ints[ints$dataset == dt, ]
      p_ints_t_i <- p_ints_t[p_ints_t$dataset == dt, ]
      per_int_ix <- which(ints_i$start_year == p_ints_t_i$start_year & ints_i$end_year == p_ints_t_i$end_year)
      if (length(per_int_ix) > 0) {
        stat_t <- rbind(stat_t, ints_i[per_int_ix, ])
        tempo_t <- tempo_t[-ints_i[per_int_ix, ]$id, ]
      }
    }
  } else {
    for (dt in unique(ints$dataset)) {
      ints_i <- ints[ints$dataset == dt, ]
      p_ints_t_i <- p_ints_t[p_ints_t$dataset == dt, ]
      per_int_ix <- which(ints_i$start_year == p_ints_t_i$start_year & ints_i$end_year == p_ints_t_i$end_year)
      if (length(per_int_ix) > 0) {
        stat_t <- rbind(stat_t, ints_i[per_int_ix, ])
      }
    }
  }
  
  # Isolate dynamic (to match) and static (no match) layers and subset info tables
  cov_tomatch <- cov_fst[tempo_t$id]
  cov_tomatch_times <- tempo_t
  
  cov_nomatch <- cov_fst[stat_t$id]
  cov_nomatch_times <- stat_t
  
  # Identify static variables also in dynamic ones
  cov_diff <- which(cov_nomatch_times$variable %in% cov_tomatch_times$variable)
  if (length(cov_diff) > 0) {
    cov_nomatch_diff <- cov_nomatch[-cov_diff]
    cov_nomatch_diff_times <- cov_nomatch_times[-cov_diff, ]
  } else {
    cov_nomatch_diff <- cov_nomatch
    cov_nomatch_diff_times <- stat_t
  }
} else {
  # Settings if no temporal matching
  cov_tomatch <- NULL
  cov_nomatch_diff <- cov_fst
  cov_nomatch_diff_times <- times
  cov_nomatch <- cov_fst
  cov_nomatch_times <- times
}


### ------------------------
### Extract presences
### ------------------------

threads_fst(nr_of_threads = 1)

# Identify cell positions once
cells <- cellFromXY(rst_ref, xy[pa == 1,])

# Static covariates (only if not included in dynamic ones)
if (!is.null(cov_nomatch_diff) && length(cov_nomatch_diff) > 0) {
  suppressMessages(xt_pres <- mclapply(cov_nomatch_diff, function(i) {
    if (file.exists(i)) {
      r <- read_fst(i)
      xt <- data.frame(r[cells, 1])
      names(xt) <- names(r)
      return(xt)
    } else {
      warning(paste("File not found:", i))
      return(NULL)
    }
  }, mc.cores = ncores))
  xt_pres_sta <- do.call(cbind, xt_pres)
}

# Dynamic covariates
if (!is.null(cov_tomatch) && length(cov_tomatch) > 0) {
  suppressMessages(xt_pres <- mclapply(cov_tomatch, function(i) {
    if (file.exists(i)) {
      r <- read_fst(i)
      xt <- data.frame(r[cells, 1])
      names(xt) <- names(r)
      return(xt)
    } else {
      warning(paste("File not found:", i))
      return(NULL)
    }
  }, mc.cores = ncores))
  
  xt_pres <- do.call(cbind, xt_pres)
  
  ## Identify year to be matched
  y <- years[pa == 1]
  
  # Nearest previous time slice
  if (tmatch_scheme == "npts") {
    suppressWarnings(maxless <- sapply(y, function(z) {
      temp <- cov_tomatch_times[, 2][cov_tomatch_times[, 2] <= z]
      if (length(temp) > 0) max(temp) else min(cov_tomatch_times$end_year)
    }))
  }
  
  # Nearest time slice
  if (tmatch_scheme == "nts") {
    suppressWarnings(maxless <- sapply(y, function(z) {
      cov_tomatch_times[, 2][which.min(abs(rowMeans(cbind(cov_tomatch_times[, 1], cov_tomatch_times[, 2])) - z))]
    }))
  }
  
  ## Thin accordingly
  y_pos <- lapply(maxless, function(t) which(cov_tomatch_times$end_year == t))
  xt_pres <- lapply(seq_along(maxless), function(w) xt_pres[w, y_pos[[w]]])
  
  ## Clean rename
  pers <- paste(unique(cov_tomatch_times[, 1]), unique(cov_tomatch_times[, 2]), sep = "_")
  pers <- sub("^(\\d+)_\\1$", "\\1", pers)
  
  for (r in seq_along(xt_pres)) {
    r_out <- xt_pres[[r]]
    for (d in p_ints_t$dataset) {
      tr <- rep(paste(p_ints_t$start_year[p_ints_t$dataset == d & p_ints_t$int == "int"],
                      p_ints_t$end_year[p_ints_t$dataset == d & p_ints_t$int == "int"], sep = "_"), length(pers))
      if (identical(cov_tomatch_times[, 1], cov_tomatch_times[, 2])) {
        tr <- rep(paste(p_ints_t$start_year[p_ints_t$dataset == d & p_ints_t$int == "int"]), length(pers))
      }
      ix <- grep(d, names(r_out))
      if (length(ix) > 0) {
        names(r_out)[ix] <- stri_replace_all_fixed(names(r_out)[ix], pers, tr, vectorize_all = FALSE)
      }
    }
    xt_pres[[r]] <- r_out
  }
  
  ## Finalize
  xt_pres_dyn <- do.call(rbind, xt_pres)
}

# Combine static and dynamic sets
sets <- c("xt_pres_sta", "xt_pres_dyn")
exi <- c(exists(sets[1]), exists(sets[2]))
valid_sets <- sets[exi]
xt_pres <- if (length(valid_sets) > 0) do.call(cbind, lapply(valid_sets, get, sys.frame(sys.parent(0)))) else NULL

  
### ------------------------
### Extract absences
### ------------------------

# Identify cell positions for absence points
cells <- cellFromXY(rst_ref, xy[pa == 0,])

if (!is.null(cov_nomatch) && length(cov_nomatch) > 0) {
  suppressMessages(xt_abs <- mclapply(cov_nomatch, function(i) {
    if (file.exists(i)) {
      r <- read_fst(i)
      xt <- data.frame(r[cells, 1])
      names(xt) <- names(r)
      return(xt)
    } else {
      warning(paste("File not found:", i))
      return(NULL)
    }
  }, mc.cores = ncores))
  
  # Remove any NULL results before binding
  xt_abs <- xt_abs[!sapply(xt_abs, is.null)]
  
  # Finalize
  if (length(xt_abs) > 0) {
    xt_abs <- do.call(cbind, xt_abs)
  } else {
    xt_abs <- NULL  # Ensure it's defined but empty
    warning("No absence data extracted: check cov_nomatch files.")
  }
} else {
  xt_abs <- NULL
  warning("cov_nomatch is empty or NULL; no absence data extracted.")
}

### ------------------------
### Combine and clean
### ------------------------

# Safely combine presence and absence data
if (!is.null(xt_pres) && !is.null(xt_abs)) {
  env_vars <- rbind(xt_pres, xt_abs)
} else {
  env_vars <- if (!is.null(xt_pres)) xt_pres else xt_abs
}

# Proceed only if env_vars is not empty
if (!is.null(env_vars) && ncol(env_vars) > 0) {

  # Clean for columns with unique values where p == 1
  lenv <- apply(env_vars[which(pa == 1), , drop = FALSE], 2, function(x) length(unique(x)))
  unique_cols <- which(lenv == 1)

  if (length(unique_cols) > 0) {
    if (ncol(env_vars) > length(unique_cols)) {
      env_vars <- env_vars[, -unique_cols, drop = FALSE]
    } else {
      warning("All columns were removed due to unique values in p == 1 subset.")
      env_vars <- NULL
    }
  }

  # Clean for near-zero variance columns
  if (is.numeric(nzvt)) {
    nzv_cols <- which(apply(env_vars, 2, function(x) length(unique(x))) < nzvt)
    if (length(nzv_cols) > 0) {
      if (ncol(env_vars) > length(nzv_cols)) {
        env_vars <- env_vars[, -nzv_cols, drop = FALSE]
      } else {
        warning("All columns were removed due to near-zero variance filtering.")
        env_vars <- NULL
      }
    }
  }

} else {
  warning("env_vars is NULL or empty after combining presences and absences.")
}

### ------------------------
### Extract mainGLO
### ------------------------

if (!is.null(cov_tif) && length(cov_tif) > 0) {
  
  # Ensure `xy` is valid before extracting cells
  if (!is.null(xy) && nrow(xy) > 0) {
    
    # Identify cells
    cells <- cellFromXY(rst_ref, xy)

    # Ensure all raster files exist before loading
    if (all(file.exists(cov_tif))) {
      
      # Load raster stack
      l <- rast(cov_tif)
      
      # Convert raster to dataframe
      r <- as.data.frame(l)
      
      # Extract values at identified cells
      xt_glo <- r[cells, , drop = FALSE]  # Extract all bands, avoid dropping dimensions

      # Ensure column names are correctly assigned
      colnames(xt_glo) <- names(l)

      # Combine with `env_vars`, ensuring `env_vars` is not NULL
      if (!is.null(env_vars) && ncol(env_vars) > 0) {
        env_vars <- cbind(env_vars, xt_glo)
      } else {
        env_vars <- xt_glo  # Initialize `env_vars` if it was NULL
      }

    } else {
      warning("Some files in `cov_tif` do not exist. Skipping mainGLO extraction.")
    }
    
  } else {
    warning("`xy` is NULL or empty, skipping `cellFromXY()` step.")
  }
  
}

### ------------------------
### Update and return
### ------------------------

# Identify rows with NA values
na_ix <- which(!complete.cases(env_vars))

# Remove rows with NAs if any exist
if (length(na_ix) > 0) {
  env_vars <- env_vars[-na_ix, , drop = FALSE]
  xy <- xy[-na_ix, , drop = FALSE]
  pa <- pa[-na_ix]
  years <- years[-na_ix]
}

# Check if `data` is an S4 object and contains required slots
  # Update `data` object
  data@env_vars <- env_vars
  data@xy <- xy
  data@pa <- pa
  data@years <- years
}
return(data)}
